---
layout: post
title: Java 编程语言学习
category : [Java]
tagline: "Supporting tagline"
tags : [Java]
---
{% include JB/setup %}
# Java 编程语言学习
---

> https://docs.oracle.com/javase/8/
>
> https://docs.oracle.com/javase/8/docs/
> 
> https://docs.oracle.com/javase/8/docs/api/
>
> [Java Tutorial](https://www.sitesbay.com/java/index)  


<!--break-->


### Run-Time Data Areas  
 
> [Run-Time Data Areas](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5) 
> [Java中的堆和栈的区别](http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/) 
> [JVM-String常量池与运行时常量池](http://blog.csdn.net/sugar_rainbow/article/details/68150249) 


Java 运行时数据区图：　
![Java 运行时数据区图](/images/2017-01-02-run-time-data-areas.png)  

#### 私有 
- 程序计数器：记录当前线程所执行字节码的行号指示器。 
- 虚拟机栈（stack）：存放了当前线程调用方法的局部变量表、操作数栈、动态链接、方法返回值等信息（可以理解为线程的栈）。 
- 本地方法栈（native stack）：为虚拟机使用的 native 方法提供服务，后多与 JVM stack 合并为一起。

#### 共享 
- Java堆（heap）：占据了虚拟机管理内存中最大的一块，唯一目的就是存放对象实例（与引用是两个概念），也是垃圾回收器主要管理的地方，故又称GC堆。 
- 方法区（method area）：存储加载的类信息、常量区、静态变量、JIT（即时编译器）处理后的数据等，类的信息包含类的版本、字段、方法、接口等信息。需要注意是常量池就在方法区中。

#### 程序计数器 
程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 
由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### 栈
Java的栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。
存取速度比堆要快，仅次于寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。栈有3个部分：基本类型变量区、执行环境上下文、操作指令区。
如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。

#### 堆
Java的堆是用来存放由 `new` 关键字创建的对象和数组，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。 
如果堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。

#### 方法区 
> 方法区（Method Area）与在逻辑上是堆的一部分，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的
  代码等数据(是唯一的数据)。当java虚拟机通过类加载器加载这个类的时候，这个类的信息就会保存到方法区中,虽然Java虚拟机规范把方法区描述为堆的
  一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 
  方法区因为总是存放不会轻易改变的内容，故又被称之为“永久代”。
  HotSpot也选择把GC分代收集扩展至方法区，但也容易遇到内存溢出问题。可以选择不实现垃圾回收，但如果回收就主要涉及常量池的回收和类的卸载

> [方法区](http://blog.csdn.net/zero__007/article/details/51043832) 
> 
> [Java虚拟机-----方法区和运行时常量池](http://blog.csdn.net/sunshine__me/article/details/49992909)  

 
> JDK1.6之前字符串常量池位于方法区之中。   
> JDK1.7字符串常量池已经被挪到堆之中。  

#### 常量池 
> [Java常量池（静态常量池与运行时常量池）](http://blog.sina.com.cn/s/blog_ee34aa660102wrk3.html) 
> 
> [Java中几种常量池的区分](https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/)
> 
> http://hzbook.group.iteye.com/group/wiki/3122-Java#3903 

##### 全局字符串池（string pool也有叫做string literal pool）。 
全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。
在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

##### 静态常量池，即class文件常量池（class constant pool） 
class文件常量池图： 
![class文件常量池](/images/2017-01-02-class-constant-pool.png)  

java代码被编译后生成。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。

##### 运行时常量池
在虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中。我们常说的常量池，就是指方法区中的运行时常量池。

##### 运行时常量池与Class文件常量池区别 
- JVM对Class文件中每一部分的格式都有严格的要求，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行；但运行时常量池没有这些限制，除了保存Class文件中描述的符号引用，还会把翻译出来的直接引用也存储在运行时常量区。
- 相较于Class文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是String类的intern()方法。
- 在方法区中，常量池有运行时常量池和Class文件常量池。
> String.intern()
  检查字符串常量池中是否存在String并返回池里的字符串引用；若池中不存在，则将其加入池中，并返回其引用。 
  这样做主要是为了避免在堆中不断地创建新的字符串对象 
  
 
### 对象和对象的引用 

> [浅谈Java中的对象和引用](https://www.cnblogs.com/dolphin0520/p/3592498.html)

#### 对象 
每个对象都是某个类（class）的一个实例（instance）。  

#### 对象的引用 
``` 
Person person = new Person("张三"); 
``` 
Java 用 new 关键字在堆上创建对象，这里的 `new Person("张三");` 就是在堆内存中创建了一个 Person 对象。 
`Person person` 声明了 `Person` 类的一个引用。 

上面的代码等价于： 
``` 
Person person;
person = new Person("张三");
``` 
引用变量和对象之间的 `=` 将 `Person` 对象的引用实际指向了一个 `Person` 类的实例。 

从存储空间上来说，对象和引用也是独立的，它们存储在不同的地方，对象存储在堆中，而引用存储在速度更快的栈中。   

#### 对象的访问 

> [](http://hzbook.group.iteye.com/group/wiki/3122-Java#3911) 

在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码： 
Object obj = new Object(); 
假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 
由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 
如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。 
![](/images/2017-01-02-object-access-handler.jpg) 

如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示。 
![](/images/2017-01-02-object-access-pointer.jpg) 

这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。


### System Properties

> https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html

user.dir : User's current working directory （用户当前的 工作目录/工程目录）

> https://stackoverflow.com/questions/16239130/java-user-dir-property-what-exactly-does-it-mean

