---
layout: post
title: Java 编程语言学习
category : [Java]
tagline: "Supporting tagline"
tags : [Java]
---
{% include JB/setup %}
# Java 编程语言学习
---

> https://docs.oracle.com/javase/8/
>
> https://docs.oracle.com/javase/8/docs/
> 
> https://docs.oracle.com/javase/8/docs/api/
>
> [Java Tutorial](https://www.sitesbay.com/java/index)  


<!--break-->


### 对象和对象的引用 

> [浅谈Java中的对象和引用](https://www.cnblogs.com/dolphin0520/p/3592498.html)

#### 对象 
每个对象都是某个类（class）的一个实例（instance）。  

#### 对象的引用 
``` 
Person person = new Person("张三"); 
``` 
Java 用 new 关键字在堆上创建对象，这里的 `new Person("张三");` 就是在堆内存中创建了一个 Person 对象。 
`Person person` 声明了 `Person` 类的一个引用。 

上面的代码等价于： 
``` 
Person person;
person = new Person("张三");
``` 
引用变量和对象之间的 `=` 将 `Person` 对象的引用实际指向了一个 `Person` 类的实例。 

从存储空间上来说，对象和引用也是独立的，它们存储在不同的地方，对象存储在堆中，而引用存储在速度更快的栈中。   

### Run-Time Data Areas  
 
> [Run-Time Data Areas](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5) 
> [Java中的堆和栈的区别](http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/) 
> [JVM-String常量池与运行时常量池](http://blog.csdn.net/sugar_rainbow/article/details/68150249) 


Java 运行时数据区图：　
![Java 运行时数据区图](/images/2017-01-02-run-time-data-areas.png)  

#### 私有 
- 程序计数器：记录当前线程所执行字节码的行号指示器。 
- 虚拟机栈（stack）：存放了当前线程调用方法的局部变量表、操作数栈、动态链接、方法返回值等信息（可以理解为线程的栈）。 
- 本地方法栈（native stack）：为虚拟机使用的 native 方法提供服务，后多与 JVM stack 合并为一起。

#### 共享 
- Java堆（heap）：占据了虚拟机管理内存中最大的一块，唯一目的就是存放对象实例（与引用是两个概念），也是垃圾回收器主要管理的地方，故又称GC堆。 
- 方法区（method area）：存储加载的类信息、常量区、静态变量、JIT（即时编译器）处理后的数据等，类的信息包含类的版本、字段、方法、接口等信息。需要注意是常量池就在方法区中。


#### 堆
Java的堆是一个运行时数据区，用来存放由 `new` 关键字创建的对象和数组，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。 
如果堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。

#### 栈
Java的栈也是一个运行时数据区，栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。
存取速度比堆要快，仅次于寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。栈有3个部分：基本类型变量区、执行环境上下文、操作指令区。
如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。

#### 方法区 
> 方法区（Method Area）与在逻辑上是堆的一部分，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的
  代码等数据(是唯一的数据)。当java虚拟机通过类加载器加载这个类的时候，这个类的信息就会保存到方法区中,虽然Java虚拟机规范把方法区描述为堆的
  一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 
  方法区因为总是存放不会轻易改变的内容，故又被称之为“永久代”。
  HotSpot也选择把GC分代收集扩展至方法区，但也容易遇到内存溢出问题。可以选择不实现垃圾回收，但如果回收就主要涉及常量池的回收和类的卸载

> [方法区](http://blog.csdn.net/zero__007/article/details/51043832) 
> 
> [Java虚拟机-----方法区和运行时常量池](http://blog.csdn.net/sunshine__me/article/details/49992909)  


 
> JDK1.6之前字符串常量池位于方法区之中。   
> JDK1.7字符串常量池已经被挪到堆之中。  

#### 常量池 
> [Java常量池（静态常量池与运行时常量池）](http://blog.sina.com.cn/s/blog_ee34aa660102wrk3.html) 
> 
> [Java中几种常量池的区分](https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/)

##### 全局字符串池（string pool也有叫做string literal pool）。 
全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。
在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

##### 静态常量池，即class文件常量池（class constant pool） 
class文件常量池图： 
![class文件常量池](/images/2017-01-02-class-constant-pool.png)  

java代码被编译后生成。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。

##### 运行时常量池
在虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中。我们常说的常量池，就是指方法区中的运行时常量池。

##### 运行时常量池与Class文件常量池区别 
- JVM对Class文件中每一部分的格式都有严格的要求，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行；但运行时常量池没有这些限制，除了保存Class文件中描述的符号引用，还会把翻译出来的直接引用也存储在运行时常量区。
- 相较于Class文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是String类的intern()方法。
- 在方法区中，常量池有运行时常量池和Class文件常量池。
> String.intern()
  检查字符串常量池中是否存在String并返回池里的字符串引用；若池中不存在，则将其加入池中，并返回其引用。 
  这样做主要是为了避免在堆中不断地创建新的字符串对象 
  


### System Properties

> https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html

user.dir : User's current working directory （用户当前的 工作目录/工程目录）

> https://stackoverflow.com/questions/16239130/java-user-dir-property-what-exactly-does-it-mean

