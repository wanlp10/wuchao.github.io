---
layout: post
title: Java 编程语言学习
category : [Java]
tagline: "Supporting tagline"
tags : [Java]
---
{% include JB/setup %}
# Java 编程语言学习
---

> https://docs.oracle.com/javase/8/
>
> https://docs.oracle.com/javase/8/docs/
> 
> https://docs.oracle.com/javase/8/docs/api/
>
> [Java Tutorial](https://www.sitesbay.com/java/index)  


<!--break-->


### 对象和对象的引用 

> [浅谈Java中的对象和引用](https://www.cnblogs.com/dolphin0520/p/3592498.html)

#### 对象 
每个对象都是某个类（class）的一个实例（instance）。  

#### 对象的引用 
``` 
Person person = new Person("张三"); 
``` 
Java 用 new 关键字在堆上创建对象，这里的 `new Person("张三");` 就是在堆内存中创建了一个 Person 对象。 
`Person person` 声明了 `Person` 类的一个引用。 

上面的代码等价于： 
``` 
Person person;
person = new Person("张三");
``` 
引用变量和对象之间的 `=` 将 `Person` 对象的引用实际指向了一个 `Person` 类的实例。 

从存储空间上来说，对象和引用也是独立的，它们存储在不同的地方，对象存储在堆中，而引用存储在速度更快的栈中。   

### Run-Time Data Areas  
 
> [Run-Time Data Areas](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5) 
> [Java中的堆和栈的区别](http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/) 

Java的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method area)。堆区只有一个，方法区只有一个，栈可以有多个，并且堆的大小要大于栈的。

#### 堆
Java的堆是一个运行时数据区，用来存放由 `new` 关键字创建的对象和数组，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。 
如果堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。

#### 栈
Java的栈也是一个运行时数据区，栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。
存取速度比堆要快，仅次于寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。栈有3个部分：基本类型变量区、执行环境上下文、操作指令区。
如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。

#### 方法区 
> 方法区（Method Area）与在逻辑上是堆的一部分，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的
  代码等数据(是唯一的数据)。当java虚拟机通过类加载器加载这个类的时候，这个类的信息就会保存到方法区中,虽然Java虚拟机规范把方法区描述为堆的
  一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 

> [方法区](http://blog.csdn.net/zero__007/article/details/51043832) 
> 
> [Java虚拟机-----方法区和运行时常量池](http://blog.csdn.net/sunshine__me/article/details/49992909)  


 
> JDK1.6之前字符串常量池位于方法区之中。   
> JDK1.7字符串常量池已经被挪到堆之中。  

#### 常量池 
> [Java常量池（静态常量池与运行时常量池）](http://blog.sina.com.cn/s/blog_ee34aa660102wrk3.html) 
> 
> [Java中几种常量池的区分](https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/)

##### 全局字符串池（string pool也有叫做string literal pool）。 
全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。
在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

##### 静态常量池，即class文件常量池（class constant pool）
java代码被编译后生成。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。

##### 运行时常量池
在jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中。我们常说的常量池，就是指方法区中的运行时常量池。


### System Properties

> https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html

user.dir : User's current working directory （用户当前的 工作目录/工程目录）

> https://stackoverflow.com/questions/16239130/java-user-dir-property-what-exactly-does-it-mean

