---
layout: post
title: Spring 的学习和使用
category : [JavaEE, Spring]
tagline: "Supporting tagline"
tags : [Spring]
---
{% include JB/setup %}
# Spring 的学习和使用
---

<!--break-->


## 2 装配 Bean 
### 2.1 Spring 配置的可选方案 
Spring 容器负责创建应用程序中的 Bean 并通过 DI 来协调这些对象之间的关系.
但是,作为开发人员,你需要告诉 Sprng 要创建哪些 Bean 并且如何将其装配在一起.
当描述 Bean 如何进行装配时,Spring 具有非常大的灵活性,它提供了三种主要的装配机制: 
- 在 XML 种进行显示配置 
- 使用 JavaConfig 进行配置 
- 隐式的 Bean 发现机制与自动装配 

### 2.2 自动化装配 Bean 
Spring 从两个角度来实现自动化装配: 
- 组建扫描(component scanning): Spring 会自动发现应用上下文中所创建的 Bean. 
- 自动装配(autowiring): Spring 自动满足 Bean 之间的依赖. 

### 2.2.1 创建可被发现的 Bean 
在类上添加 @Component 注解表明该类会作为组件类,并告知 Spring 要为这个类
创建 Bean.不过组件的扫描默认是不启用的.我们还需要显式配置一下 Spring,从而命令它去寻找带有
 @Component 注解的类.Spring 中可以使用 @ComponentScan 注解启用组件扫描. 
如果没有其他配置的话, @ComponentScan 默认会扫描与配置类所在包及该包下的所有子包,
寻找带有 @Component 注解的类,并且在 Spring 种为其创建一个 Bean. 
如果使用 XML 来启用组件扫描的话,那么可以使用 Spring context 命名空间的
`<context:component-scan>` 元素. 

### 2.2.2 为组件扫描的 Bean 命名 
Spring 应用上下文中所有的 Bean 都会给定一个 ID,如果没有显示指定,Spring
会根据类名为其指定一个 ID(将类名的第一个字母变为小写). 
如果想要为这个 Bean 设置不同的 ID,你所要做的就是将期望的 ID 作为值传递给
 @Component 注解: 
 ``` 
 @Component("lonelyHeartsClub")
 public class SgtPeppers implements CompactDisc {
    ...
 }
 ``` 
还有另外一种为 Bean 命名的方式,这种方式不使用 @Component 注解,而是使用
Java 依赖注入规范(Java Dependency Injection) 中所提供的 @Named 注解
来为 Bean 设置 ID: 
``` 
package soundsystem; 
import javax.inject.Named;

@Named("lonelyHeartsClub") 
public class SgtPeppers implements CompactDisc {
    ...
}
``` 
Spring 支持将 @Named 作为 @Component 注解的替代方案,两者之间有一些细微的差异,
但是在大多数场景中,它们是可以相互替换的. 

### 2.2.3 设置组件扫描的基础包 
到现在为止,我们没有为 @ComponentScan 注解设置任何属性.这意味着,按照默认规则,
它会以配置类所在的包作为基础包(base package)来扫描组件.但是,如果你想扫描不同的包,
那该怎么办呢?或者,如果你想扫描多个基础包,那又该怎么办呢?   

有一个原因会促使我们明确地设置基础包,那就是我们想要将配置类放在单独的包中,
使其与其他应用代码区分开来.如果是这样的话,哪默认的基础包就不能满足要求了.  

要满足这样的需求其实也完全没有问题!为了指定不同的基础包,你所需要做的就是在 @ComponentScan
的 value 属性中指明包的名称: 
``` 
@Configuration  
@ComponentScan(basePackages="soundsystem")
public class CPPlayerConfig {} 
``` 

如果你想更加清晰地表明你所设置的是基础包,那么你可以通过 basePackages 属性进行设置: 
``` 
@Configuration
@ComponentScan(basePackages="soundsystem")
public class CDPlayerConfig {}
``` 

可能你已经注意到了 basePackages 属性使用的是复数形式.如果你揣测这是不是意味着可以设置多个基础包,
那么恭喜你猜对了,如果想要这么做的话,只需要将 basePackages 属性设置为要扫描包的一个数组即可: 
``` 
@Configuration
@ComponentScan(basePackages{"soundsystem", "video"})
public class CDPlayerconfig {}
``` 

在上面的例子中,所设置的基础包是以 String 类型表示的,我认为这是可以的,但这种方法是类型不安全的(not type-safe)
的.如果你重构代码的话,那么所指定的基础包可能就会出现错误了.   

除了将包设置为简单的 String 类型之外,@ComponentScan 还提供了另外一种方法,那就是将其指定为包中所
包含的类或接口: 
``` 
@Configuration
@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})
public class CDPlayerConfig {} 
``` 

可以看到,basePackages 属性被替换成了 basePackageClasses.同时,我们不是再使用 String 类型的
名称来指定包,为 basePackageClasses 属性所设置的数组中包含了类.这些类所在的包将会作为组件扫描的基础包.   

尽管在样例中,为 basePackageClasses 设置的是组件类,但是你可以考虑在包中创建一个用来进行扫描的
空标记接口(marker interface).通过标记接口的方式,你依然能够保持对重构友好的接口引用,但是可以避免
引用任何实际的应用程序代码卡.  

在你的应用程序中,如果所有的对象都是独立的,彼此之间没有任何依赖,那么你所需要的可能就是组件扫描而已.
但是,很多对象会依赖其他的对象才能完成任务.这样的话,我们就需要有一种方法能够将组件扫描得到的 bean 
和它们的依赖装配在一起.要完成这项任务,我们需要了解一下 Spring 自动装配的另外一方面内容 -- 自动装配.  

### 2.2.4 通过为 Bean 添加注解实现自动装配  
简单来说,自动装配就是让 Spring 自动满足 Bean 依赖的一种方法,在满足依赖的过程中,会在 Spring 应用上下文中
寻找匹配某个 Bean 需求的其他 Bean.为了声明要进行自动装配,我们可以借助 Spring 的 @Autowired 注解. 

比方说,下面的 CDPlayer 类,它的构造上添加了 @Autowired 注解,这表明当 Spring 创建 CDPlayer Bean
的时候,会通过这个构造器来进行实例化并且会传入一个可设置给 CompactDisc 类型的 Bean.   

``` 
# 通过自动装配,将一个 CompactDisc 注入到 CDPlayer 之中     
  
package soundsystem ;
import.org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class CDPlayer implements MediaPlayer {
    private CompactDisc cd;
    
    @Autowired
    public CDPlayer(CompactDisc cd) {
        this.cd = cd; 
    } 
    
    public void play() {
        cd.play();
    }
}
``` 
@Autowired 注解不仅能够用在构造器上,还能用在属性的 Setter 方法上,比如说,CDPlayer 有一个 setCompactDisc() 
方法,那么可以采用如下的注解形式进行自动装配: 
``` 
@Autowired
public void setCompactDisc(CompactDisc cd) {
    this.cd = cd;
}
```  

在 Spring 初始化 Bean 之后,它会尽可能的去满足 Bean 的依赖,在本例中,依赖是通过带有 @Autowired 注解
的方法进行声明的,也就是 setCompactDisc() 方法.   

实际上, Setter 方法并没有什么特殊之处,@Autowired 注解可以用在类的任何方法上.假设 CDPlayer 类有一个 
insertDisc() 方法,那么 @Autowired 能够像在 setCompactDisc() 上那样,发挥完全相同的作用: 
``` 
@Autowired
public void insertDisc(CompactDisc cd) {
    this.cd = cd;
}
```    

不管是构造器,Setter 方法还是其他的方法,Spring 都会尝试满足方法参数上所声明的依赖.假如有且只有一个 Bean 
匹配依赖需求的话,那么这个 Bean 将会被装配进来.   

如果没有匹配的 Bean,那么在应用上下文创建的时候,Spring 会抛出一个异常.为避免异常的出现,你可以将 @Autowired 
的 required 属性设置为 false: 
``` 
@Autowired(required=false)
public CDPlayer(CompactDisc cd) {
    this.cd = cd;
}
```  

> Xml配置中的 Bean 要顺序定义.   

将 required 属性设置为 false 时,Spring 会尝试执行自动装配,但是如果没有匹配的 Bean 的话,Spring 
将会让这个 Bean 处于未装配的状态.但是,把 required 属性设置为 false 时,你需要谨慎对待.如果在你的代码
种没有进行 null 检查的话,这个处于未装配状态的属性有可能会出现 NullPointerException.    

如果有多个 Bean 都能满足依赖关系的话,Spring 将会抛出一个异常,表明没有明确指定要选择哪个 Bean 进行自动装配.   

@Autowired 注解是 Spring 特有的注解,如果你不愿意在代码中到处使用 Spring 的特定注解来完成自动装配
任务的话,那么你可以考虑将其替换为 @Inject: 
``` 
package soundsystem;
import javax.inject.Inject;
import javax.inject.Named;

@Named
public class CDPlayer {
    ... 
    
    @Inject
    public CDPlayer(CompactDisc cd) {
        this.cd = cd;
    }
}
```    

@Inject 注解来源于 Java 依赖注入规范,该规范同时还为我们定义了 @Named 注解.在自动装配中,Spring 同时支持 
@Inject 和 @Autowired.尽管 @Inject 和 @Autowired 之间有着一些细微的差别,但是在大多数场景下,它们都是
可以互相替换的.    

### 2.2.5 验证自动装配    
现在,我们已经在 CDPlayer 的构造器中添加了 @Autowired 注解,Spring 将把一个可分配给 CompactDisc 类型的 
Bean 自动注入进来.    
 
## 2.3 通过 Java 代码装配 Bean    

 



