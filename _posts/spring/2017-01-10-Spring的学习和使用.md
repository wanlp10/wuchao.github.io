---
layout: post
title: Spring 的学习和使用
category : [JavaEE, Spring]
tagline: "Supporting tagline"
tags : [Spring]
---
{% include JB/setup %}
# Spring 的学习和使用
---

<!--break-->


## 2 装配 Bean 
### 2.1 Spring 配置的可选方案 
Spring 容器负责创建应用程序中的 Bean 并通过 DI 来协调这些对象之间的关系.
但是,作为开发人员,你需要告诉 Sprng 要创建哪些 Bean 并且如何将其装配在一起.
当描述 Bean 如何进行装配时,Spring 具有非常大的灵活性,它提供了三种主要的装配机制: 
- 在 XML 种进行显示配置 
- 使用 JavaConfig 进行配置 
- 隐式的 Bean 发现机制与自动装配 

### 2.2 自动化装配 Bean 
Spring 从两个角度来实现自动化装配: 
- 组建扫描(component scanning): Spring 会自动发现应用上下文中所创建的 Bean. 
- 自动装配(autowiring): Spring 自动满足 Bean 之间的依赖. 

### 2.2.1 创建可被发现的 Bean 
在类上添加 @Component 注解表明该类会作为组件类,并告知 Spring 要为这个类
创建 Bean.不过组件的扫描默认是不启用的.我们还需要显式配置一下 Spring,从而命令它去寻找带有
 @Component 注解的类.Spring 中可以使用 @ComponentScan 注解启用组件扫描. 
如果没有其他配置的话, @ComponentScan 默认会扫描与配置类所在包及该包下的所有子包,
寻找带有 @Component 注解的类,并且在 Spring 种为其创建一个 Bean. 
如果使用 XML 来启用组件扫描的话,那么可以使用 Spring context 命名空间的
`<context:component-scan>` 元素. 

### 2.2.2 为组件扫描的 Bean 命名 
Spring 应用上下文中所有的 Bean 都会给定一个 ID,如果没有显示指定,Spring
会根据类名为其指定一个 ID(将类名的第一个字母变为小写). 
如果想要为这个 Bean 设置不同的 ID,你所要做的就是将期望的 ID 作为值传递给
 @Component 注解: 
 ``` 
 @Component("lonelyHeartsClub")
 public class SgtPeppers implements CompactDisc {
    ...
 }
 ``` 
还有另外一种为 Bean 命名的方式,这种方式不使用 @Component 注解,而是使用
Java 依赖注入规范(Java Dependency Injection) 中所提供的 @Named 注解
来为 Bean 设置 ID: 
``` 
package soundsystem; 
import javax.inject.Named;

@Named("lonelyHeartsClub") 
public class SgtPeppers implements CompactDisc {
    ...
}
``` 
Spring 支持将 @Named 作为 @Component 注解的替代方案,两者之间有一些细微的差异,
但是在大多数场景中,它们是可以相互替换的. 

### 2.2.3 设置组件扫描的基础包 
到现在为止,我们没有为 @ComponentScan 注解设置任何属性.这意味着,按照默认规则,
它会以配置类所在的包作为基础包(base package)来扫描组件.但是,如果你想扫描不同的包,
那该怎么办呢?或者,如果你想扫描多个基础包,那又该怎么办呢?   

有一个原因会促使我们明确地设置基础包,那就是我们想要将配置类放在单独的包中,
使其与其他应用代码区分开来.如果是这样的话,哪默认的基础包就不能满足要求了.  

要满足这样的需求其实也完全没有问题!为了指定不同的基础包,你所需要做的就是在 @ComponentScan
的 value 属性中指明包的名称: 
``` 
@Configuration  
@ComponentScan(basePackages="soundsystem")
public class CPPlayerConfig {} 
``` 

如果你想更加清晰地表明你所设置的是基础包,那么你可以通过 basePackages 属性进行设置: 
``` 
@Configuration
@ComponentScan(basePackages="soundsystem")
public class CDPlayerConfig {}
``` 

可能你已经注意到了 basePackages 属性使用的是复数形式.如果你揣测这是不是意味着可以设置多个基础包,
那么恭喜你猜对了,如果想要这么做的话,只需要将 basePackages 属性设置为要扫描包的一个数组即可: 
``` 
@Configuration
@ComponentScan(basePackages{"soundsystem", "video"})
public class CDPlayerconfig {}
``` 

在上面的例子中,所设置的基础包是以 String 类型表示的,我认为这是可以的,但这种方法是类型不安全的(not type-safe)
的.如果你重构代码的话,那么所指定的基础包可能就会出现错误了.   

除了将包设置为简单的 String 类型之外,@ComponentScan 还提供了另外一种方法,那就是将其指定为包中所
包含的类或接口: 
``` 
@Configuration
@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})
public class CDPlayerConfig {} 
``` 

可以看到,basePackages 属性被替换成了 basePackageClasses.同时,我们不是再使用 String 类型的
名称来指定包,为 basePackageClasses 属性所设置的数组中包含了类.这些类所在的包将会作为组件扫描的基础包.   

尽管在样例中,为 basePackageClasses 设置的是组件类,但是你可以考虑在包中创建一个用来进行扫描的
空标记接口(marker interface).通过标记接口的方式,你依然能够保持对重构友好的接口引用,但是可以避免
引用任何实际的应用程序代码卡.  

在你的应用程序中,如果所有的对象都是独立的,彼此之间没有任何依赖,那么你所需要的可能就是组件扫描而已.
但是,很多对象会依赖其他的对象才能完成任务.这样的话,我们就需要有一种方法能够将组件扫描得到的 bean 
和它们的依赖装配在一起.要完成这项任务,我们需要了解一下 Spring 自动装配的另外一方面内容 -- 自动装配.  

### 2.2.4 通过为 Bean 添加注解实现自动装配   


